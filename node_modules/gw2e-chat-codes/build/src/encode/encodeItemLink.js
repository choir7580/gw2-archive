"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeItemLink = void 0;
var static_1 = require("../static");
var ChatCodeStruct_1 = require("../ChatCodeStruct");
function encodeItemLink(meta) {
    // Make sure the ID is valid
    var id = parseInt('' + meta.id, 10);
    if (isNaN(id) || id < 0)
        return false;
    var struct = new ChatCodeStruct_1.ChatCodeStruct();
    // Add the header describing the type of the chat code
    struct.write1Byte(static_1.TYPE_HEADERS.item);
    // The quantity of items is encoded as a single byte before the ID
    struct.write1Byte(meta.quantity || 1);
    // Encode the ID as a 3-byte little endian integer
    struct.write3Bytes(id);
    // Get the skin and upgrades as integer
    var skin = parseInt('' + meta.skin, 10);
    var upgrade1 = meta.upgrades && parseInt('' + meta.upgrades[0], 10);
    var upgrade2 = meta.upgrades && parseInt('' + meta.upgrades[1], 10);
    // Check which flags should be set
    var hasSkin = !isNaN(skin);
    var hasUpgrade1 = upgrade1 && !isNaN(upgrade1);
    var hasUpgrade2 = upgrade2 && !isNaN(upgrade2);
    // Encode the flags
    var flags = 0;
    if (hasSkin)
        flags |= static_1.ITEM_FLAGS.skin;
    if (hasUpgrade1)
        flags |= static_1.ITEM_FLAGS.upgrade1;
    if (hasUpgrade2)
        flags |= static_1.ITEM_FLAGS.upgrade2;
    struct.write1Byte(flags);
    // Encode the skin id
    if (hasSkin) {
        struct.write3Bytes(skin);
        struct.write1Byte(0x00);
    }
    // Encode the first upgrade slot
    if (hasUpgrade1) {
        struct.write3Bytes(upgrade1);
        struct.write1Byte(0x00);
    }
    // Encode the second upgrade slot
    if (hasUpgrade2) {
        struct.write3Bytes(upgrade2);
        struct.write1Byte(0x00);
    }
    return struct.encodeToChatCode();
}
exports.encodeItemLink = encodeItemLink;
//# sourceMappingURL=encodeItemLink.js.map