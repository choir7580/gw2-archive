"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBuildLink = void 0;
var static_1 = require("../static");
var ChatCodeStruct_1 = require("../ChatCodeStruct");
function encodeBuildLink(meta) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var struct = new ChatCodeStruct_1.ChatCodeStruct();
    // Add the header describing the type of the chat code
    struct.write1Byte(static_1.TYPE_HEADERS.build);
    struct.write1Byte(meta.profession);
    struct.write1Byte(meta.specialization1);
    struct.writeTraitSelection(meta.traitChoices1);
    struct.write1Byte(meta.specialization2);
    struct.writeTraitSelection(meta.traitChoices2);
    struct.write1Byte(meta.specialization3);
    struct.writeTraitSelection(meta.traitChoices3);
    struct.write2Bytes(meta.terrestrialHealSkill);
    struct.write2Bytes(meta.aquaticHealSkill);
    struct.write2Bytes(meta.terrestrialUtilitySkill1);
    struct.write2Bytes(meta.aquaticUtilitySkill1);
    struct.write2Bytes(meta.terrestrialUtilitySkill2);
    struct.write2Bytes(meta.aquaticUtilitySkill2);
    struct.write2Bytes(meta.terrestrialUtilitySkill3);
    struct.write2Bytes(meta.aquaticUtilitySkill3);
    struct.write2Bytes(meta.terrestrialEliteSkill);
    struct.write2Bytes(meta.aquaticEliteSkill);
    if (meta.profession === static_1.PROFESSION_FLAGS.ranger) {
        // Ranger
        struct.write1Byte((_a = meta.terrestrialPet1) !== null && _a !== void 0 ? _a : 0);
        struct.write1Byte((_b = meta.terrestrialPet2) !== null && _b !== void 0 ? _b : 0);
        struct.write1Byte((_c = meta.aquaticPet1) !== null && _c !== void 0 ? _c : 0);
        struct.write1Byte((_d = meta.aquaticPet2) !== null && _d !== void 0 ? _d : 0);
        // Zero out the bytes used for Revenant
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
    }
    else if (meta.profession === static_1.PROFESSION_FLAGS.revenant) {
        // Revenant
        struct.write1Byte((_e = meta.terrestrialLegend1) !== null && _e !== void 0 ? _e : 0);
        struct.write1Byte((_f = meta.terrestrialLegend2) !== null && _f !== void 0 ? _f : 0);
        struct.write1Byte((_g = meta.aquaticLegend1) !== null && _g !== void 0 ? _g : 0);
        struct.write1Byte((_h = meta.aquaticLegend2) !== null && _h !== void 0 ? _h : 0);
        // TODO (Feature) We could also encode the inactive legends but not in the API
        //  so we just default to the default sort order by 0-ing them.
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
    }
    else {
        // Zero out the bytes used for Ranger / Revenant
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        // Zero out the bytes used for Revenant
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
        struct.write2Bytes(0x00);
    }
    struct.writeDynamicArray((_j = meta.selectedWeapons) !== null && _j !== void 0 ? _j : [], 2);
    struct.writeDynamicArray((_k = meta.selectedSkillVariants) !== null && _k !== void 0 ? _k : [], 4);
    return struct.encodeToChatCode();
}
exports.encodeBuildLink = encodeBuildLink;
//# sourceMappingURL=encodeBuildLink.js.map